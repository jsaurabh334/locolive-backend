// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: crossings.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCrossing = `-- name: CreateCrossing :one
INSERT INTO crossings (
  user_id_1,
  user_id_2,
  location_center,
  occurred_at
) VALUES (
  $1, $2, $3, $4
) RETURNING id, user_id_1, user_id_2, location_center, occurred_at, created_at
`

type CreateCrossingParams struct {
	UserID1        uuid.UUID `json:"user_id_1"`
	UserID2        uuid.UUID `json:"user_id_2"`
	LocationCenter string    `json:"location_center"`
	OccurredAt     time.Time `json:"occurred_at"`
}

func (q *Queries) CreateCrossing(ctx context.Context, arg CreateCrossingParams) (Crossing, error) {
	row := q.db.QueryRowContext(ctx, createCrossing,
		arg.UserID1,
		arg.UserID2,
		arg.LocationCenter,
		arg.OccurredAt,
	)
	var i Crossing
	err := row.Scan(
		&i.ID,
		&i.UserID1,
		&i.UserID2,
		&i.LocationCenter,
		&i.OccurredAt,
		&i.CreatedAt,
	)
	return i, err
}

const findPotentialCrossings = `-- name: FindPotentialCrossings :many
SELECT 
    l1.user_id AS user1, 
    l2.user_id AS user2, 
    l1.geohash AS location, 
    l1.time_bucket
FROM locations l1
JOIN locations l2 ON l1.geohash = l2.geohash AND l1.time_bucket = l2.time_bucket
JOIN users u1 ON l1.user_id = u1.id
JOIN users u2 ON l2.user_id = u2.id
WHERE l1.user_id < l2.user_id
AND l1.time_bucket >= $1::timestamptz
AND l1.time_bucket < $2::timestamptz
AND u1.is_ghost_mode = false
AND u2.is_ghost_mode = false
GROUP BY l1.user_id, l2.user_id, l1.geohash, l1.time_bucket
`

type FindPotentialCrossingsParams struct {
	MinTime time.Time `json:"min_time"`
	MaxTime time.Time `json:"max_time"`
}

type FindPotentialCrossingsRow struct {
	User1      uuid.UUID `json:"user1"`
	User2      uuid.UUID `json:"user2"`
	Location   string    `json:"location"`
	TimeBucket time.Time `json:"time_bucket"`
}

func (q *Queries) FindPotentialCrossings(ctx context.Context, arg FindPotentialCrossingsParams) ([]FindPotentialCrossingsRow, error) {
	rows, err := q.db.QueryContext(ctx, findPotentialCrossings, arg.MinTime, arg.MaxTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPotentialCrossingsRow
	for rows.Next() {
		var i FindPotentialCrossingsRow
		if err := rows.Scan(
			&i.User1,
			&i.User2,
			&i.Location,
			&i.TimeBucket,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrossingsForUser = `-- name: GetCrossingsForUser :many
SELECT c.id, c.user_id_1, c.user_id_2, c.location_center, c.occurred_at, c.created_at FROM crossings c
JOIN users u1 ON c.user_id_1 = u1.id
JOIN users u2 ON c.user_id_2 = u2.id
WHERE (c.user_id_1 = $1 OR c.user_id_2 = $1)
AND u1.is_ghost_mode = false
AND u2.is_ghost_mode = false
ORDER BY c.occurred_at DESC
`

func (q *Queries) GetCrossingsForUser(ctx context.Context, userID1 uuid.UUID) ([]Crossing, error) {
	rows, err := q.db.QueryContext(ctx, getCrossingsForUser, userID1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crossing
	for rows.Next() {
		var i Crossing
		if err := rows.Scan(
			&i.ID,
			&i.UserID1,
			&i.UserID2,
			&i.LocationCenter,
			&i.OccurredAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
