// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
  reporter_id,
  target_user_id,
  target_story_id,
  reason,
  description
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, reporter_id, target_user_id, target_story_id, reason, description, is_resolved, created_at
`

type CreateReportParams struct {
	ReporterID    uuid.UUID      `json:"reporter_id"`
	TargetUserID  uuid.NullUUID  `json:"target_user_id"`
	TargetStoryID uuid.NullUUID  `json:"target_story_id"`
	Reason        ReportReason   `json:"reason"`
	Description   sql.NullString `json:"description"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, createReport,
		arg.ReporterID,
		arg.TargetUserID,
		arg.TargetStoryID,
		arg.Reason,
		arg.Description,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.ReporterID,
		&i.TargetUserID,
		&i.TargetStoryID,
		&i.Reason,
		&i.Description,
		&i.IsResolved,
		&i.CreatedAt,
	)
	return i, err
}

const listReports = `-- name: ListReports :many
SELECT r.id, r.reporter_id, r.target_user_id, r.target_story_id, r.reason, r.description, r.is_resolved, r.created_at, 
  u1.username as reporter_username,
  u2.username as target_username
FROM reports r
LEFT JOIN users u1 ON r.reporter_id = u1.id
LEFT JOIN users u2 ON r.target_user_id = u2.id
WHERE is_resolved = $1
ORDER BY r.created_at DESC
LIMIT $2 OFFSET $3
`

type ListReportsParams struct {
	IsResolved bool  `json:"is_resolved"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type ListReportsRow struct {
	ID               uuid.UUID      `json:"id"`
	ReporterID       uuid.UUID      `json:"reporter_id"`
	TargetUserID     uuid.NullUUID  `json:"target_user_id"`
	TargetStoryID    uuid.NullUUID  `json:"target_story_id"`
	Reason           ReportReason   `json:"reason"`
	Description      sql.NullString `json:"description"`
	IsResolved       bool           `json:"is_resolved"`
	CreatedAt        time.Time      `json:"created_at"`
	ReporterUsername sql.NullString `json:"reporter_username"`
	TargetUsername   sql.NullString `json:"target_username"`
}

// Admin: List all reports
func (q *Queries) ListReports(ctx context.Context, arg ListReportsParams) ([]ListReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, listReports, arg.IsResolved, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReportsRow
	for rows.Next() {
		var i ListReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.ReporterID,
			&i.TargetUserID,
			&i.TargetStoryID,
			&i.Reason,
			&i.Description,
			&i.IsResolved,
			&i.CreatedAt,
			&i.ReporterUsername,
			&i.TargetUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveReport = `-- name: ResolveReport :one
UPDATE reports
SET is_resolved = true
WHERE id = $1
RETURNING id, reporter_id, target_user_id, target_story_id, reason, description, is_resolved, created_at
`

// Admin: Resolve report
func (q *Queries) ResolveReport(ctx context.Context, id uuid.UUID) (Report, error) {
	row := q.db.QueryRowContext(ctx, resolveReport, id)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.ReporterID,
		&i.TargetUserID,
		&i.TargetStoryID,
		&i.Reason,
		&i.Description,
		&i.IsResolved,
		&i.CreatedAt,
	)
	return i, err
}
