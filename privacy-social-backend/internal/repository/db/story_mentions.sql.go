// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: story_mentions.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createStoryMention = `-- name: CreateStoryMention :one
INSERT INTO story_mentions (
  story_id,
  mentioned_user_id
) VALUES (
  $1, $2
) ON CONFLICT (story_id, mentioned_user_id) DO NOTHING
RETURNING id, story_id, mentioned_user_id, created_at
`

type CreateStoryMentionParams struct {
	StoryID         uuid.UUID `json:"story_id"`
	MentionedUserID uuid.UUID `json:"mentioned_user_id"`
}

func (q *Queries) CreateStoryMention(ctx context.Context, arg CreateStoryMentionParams) (StoryMention, error) {
	row := q.db.QueryRowContext(ctx, createStoryMention, arg.StoryID, arg.MentionedUserID)
	var i StoryMention
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.MentionedUserID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteStoryMentions = `-- name: DeleteStoryMentions :exec
DELETE FROM story_mentions
WHERE story_id = $1
`

func (q *Queries) DeleteStoryMentions(ctx context.Context, storyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteStoryMentions, storyID)
	return err
}

const getStoryMentions = `-- name: GetStoryMentions :many
SELECT sm.id, sm.story_id, sm.mentioned_user_id, sm.created_at, u.username, u.avatar_url
FROM story_mentions sm
JOIN users u ON sm.mentioned_user_id = u.id
WHERE sm.story_id = $1
ORDER BY sm.created_at DESC
`

type GetStoryMentionsRow struct {
	ID              uuid.UUID      `json:"id"`
	StoryID         uuid.UUID      `json:"story_id"`
	MentionedUserID uuid.UUID      `json:"mentioned_user_id"`
	CreatedAt       time.Time      `json:"created_at"`
	Username        string         `json:"username"`
	AvatarUrl       sql.NullString `json:"avatar_url"`
}

func (q *Queries) GetStoryMentions(ctx context.Context, storyID uuid.UUID) ([]GetStoryMentionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoryMentions, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoryMentionsRow
	for rows.Next() {
		var i GetStoryMentionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.MentionedUserID,
			&i.CreatedAt,
			&i.Username,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMentions = `-- name: GetUserMentions :many
SELECT sm.id, sm.story_id, sm.mentioned_user_id, sm.created_at, s.media_url, s.media_type, u.username as story_author
FROM story_mentions sm
JOIN stories s ON sm.story_id = s.id
JOIN users u ON s.user_id = u.id
WHERE sm.mentioned_user_id = $1
AND s.expires_at > now()
ORDER BY sm.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserMentionsParams struct {
	MentionedUserID uuid.UUID `json:"mentioned_user_id"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
}

type GetUserMentionsRow struct {
	ID              uuid.UUID `json:"id"`
	StoryID         uuid.UUID `json:"story_id"`
	MentionedUserID uuid.UUID `json:"mentioned_user_id"`
	CreatedAt       time.Time `json:"created_at"`
	MediaUrl        string    `json:"media_url"`
	MediaType       string    `json:"media_type"`
	StoryAuthor     string    `json:"story_author"`
}

func (q *Queries) GetUserMentions(ctx context.Context, arg GetUserMentionsParams) ([]GetUserMentionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMentions, arg.MentionedUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserMentionsRow
	for rows.Next() {
		var i GetUserMentionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.MentionedUserID,
			&i.CreatedAt,
			&i.MediaUrl,
			&i.MediaType,
			&i.StoryAuthor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
