// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stories.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createStory = `-- name: CreateStory :one
INSERT INTO stories (
  user_id,
  media_url,
  media_type,
  caption,
  geohash,
  geom,
  is_anonymous,
  is_premium,
  expires_at
) VALUES (
  $1, $2, $3, $4, $5, ST_SetSRID(ST_MakePoint($6::float8, $7::float8), 4326), $8, $9, $10
) RETURNING id, user_id, media_url, media_type, thumbnail_url, caption, geohash, geom, visibility, expires_at, created_at, is_anonymous, is_premium
`

type CreateStoryParams struct {
	UserID      uuid.UUID      `json:"user_id"`
	MediaUrl    string         `json:"media_url"`
	MediaType   string         `json:"media_type"`
	Caption     sql.NullString `json:"caption"`
	Geohash     string         `json:"geohash"`
	Lng         float64        `json:"lng"`
	Lat         float64        `json:"lat"`
	IsAnonymous bool           `json:"is_anonymous"`
	IsPremium   sql.NullBool   `json:"is_premium"`
	ExpiresAt   time.Time      `json:"expires_at"`
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (Story, error) {
	row := q.db.QueryRowContext(ctx, createStory,
		arg.UserID,
		arg.MediaUrl,
		arg.MediaType,
		arg.Caption,
		arg.Geohash,
		arg.Lng,
		arg.Lat,
		arg.IsAnonymous,
		arg.IsPremium,
		arg.ExpiresAt,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaUrl,
		&i.MediaType,
		&i.ThumbnailUrl,
		&i.Caption,
		&i.Geohash,
		&i.Geom,
		&i.Visibility,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.IsAnonymous,
		&i.IsPremium,
	)
	return i, err
}

const deleteExpiredStories = `-- name: DeleteExpiredStories :exec
DELETE FROM stories
WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredStories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredStories)
	return err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories
WHERE id = $1
`

// Admin: Delete story
func (q *Queries) DeleteStory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteStory, id)
	return err
}

const getConnectionStories = `-- name: GetConnectionStories :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous, s.is_premium, u.username, u.avatar_url, u.is_premium
FROM stories s
JOIN users u ON s.user_id = u.id
JOIN connections c ON 
  (c.requester_id = $1 AND c.target_id = s.user_id) OR
  (c.target_id = $1 AND c.requester_id = s.user_id)
WHERE 
  c.status = 'accepted'
  AND s.expires_at > now()
  AND u.is_shadow_banned = false
  AND u.is_shadow_banned = false
  -- strict streak rule (DISABLED)
  -- AND DATE(u.last_active_at) >= CURRENT_DATE - INTERVAL '1 day'
  -- Block Logic: Exclude if blocked by either party
  AND NOT EXISTS (
    SELECT 1 FROM blocked_users bu 
    WHERE (bu.blocker_id = $1 AND bu.blocked_id = s.user_id)
       OR (bu.blocker_id = s.user_id AND bu.blocked_id = $1)
  )
ORDER BY s.created_at DESC
`

type GetConnectionStoriesRow struct {
	ID           uuid.UUID         `json:"id"`
	UserID       uuid.UUID         `json:"user_id"`
	MediaUrl     string            `json:"media_url"`
	MediaType    string            `json:"media_type"`
	ThumbnailUrl sql.NullString    `json:"thumbnail_url"`
	Caption      sql.NullString    `json:"caption"`
	Geohash      string            `json:"geohash"`
	Geom         interface{}       `json:"geom"`
	Visibility   StoryAvailability `json:"visibility"`
	ExpiresAt    time.Time         `json:"expires_at"`
	CreatedAt    time.Time         `json:"created_at"`
	IsAnonymous  bool              `json:"is_anonymous"`
	IsPremium    sql.NullBool      `json:"is_premium"`
	Username     string            `json:"username"`
	AvatarUrl    sql.NullString    `json:"avatar_url"`
	IsPremium_2  sql.NullBool      `json:"is_premium_2"`
}

// Get stories from connected users (not limited by radius)
func (q *Queries) GetConnectionStories(ctx context.Context, userID uuid.UUID) ([]GetConnectionStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getConnectionStories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionStoriesRow
	for rows.Next() {
		var i GetConnectionStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
			&i.IsPremium,
			&i.Username,
			&i.AvatarUrl,
			&i.IsPremium_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoriesInBounds = `-- name: GetStoriesInBounds :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous, s.is_premium, u.username, u.avatar_url 
FROM stories s
JOIN users u ON s.user_id = u.id
WHERE s.geom && ST_MakeEnvelope($1::float8, $2::float8, $3::float8, $4::float8, 4326)
AND s.expires_at > now()
AND u.is_shadow_banned = false
AND u.is_ghost_mode = false
AND NOT EXISTS (
    SELECT 1 FROM blocked_users bu 
    WHERE (bu.blocker_id = $5 AND bu.blocked_id = s.user_id)
       OR (bu.blocker_id = s.user_id AND bu.blocked_id = $5)
)
AND (
    s.user_id = $5
    OR
    -- Fallback: If no privacy settings exist, default to PUBLIC
    NOT EXISTS (SELECT 1 FROM privacy_settings ps WHERE ps.user_id = s.user_id)
    OR
    EXISTS (
        SELECT 1 FROM privacy_settings ps 
        WHERE ps.user_id = s.user_id 
        AND ps.show_location = true
        AND (
            ps.who_can_see_stories = 'everyone'
            OR
            (ps.who_can_see_stories = 'connections' AND EXISTS (
                 SELECT 1 FROM connections c 
                 WHERE (c.requester_id = $5 AND c.target_id = s.user_id OR c.requester_id = s.user_id AND c.target_id = $5)
                 AND c.status = 'accepted'
            ))
        )
    )
)
ORDER BY s.created_at DESC
LIMIT 100
`

type GetStoriesInBoundsParams struct {
	West          float64   `json:"west"`
	South         float64   `json:"south"`
	East          float64   `json:"east"`
	North         float64   `json:"north"`
	CurrentUserID uuid.UUID `json:"current_user_id"`
}

type GetStoriesInBoundsRow struct {
	ID           uuid.UUID         `json:"id"`
	UserID       uuid.UUID         `json:"user_id"`
	MediaUrl     string            `json:"media_url"`
	MediaType    string            `json:"media_type"`
	ThumbnailUrl sql.NullString    `json:"thumbnail_url"`
	Caption      sql.NullString    `json:"caption"`
	Geohash      string            `json:"geohash"`
	Geom         interface{}       `json:"geom"`
	Visibility   StoryAvailability `json:"visibility"`
	ExpiresAt    time.Time         `json:"expires_at"`
	CreatedAt    time.Time         `json:"created_at"`
	IsAnonymous  bool              `json:"is_anonymous"`
	IsPremium    sql.NullBool      `json:"is_premium"`
	Username     string            `json:"username"`
	AvatarUrl    sql.NullString    `json:"avatar_url"`
}

// Get stories within a bounding box for map view
// AND DATE(u.last_active_at) >= CURRENT_DATE - INTERVAL '1 day'
func (q *Queries) GetStoriesInBounds(ctx context.Context, arg GetStoriesInBoundsParams) ([]GetStoriesInBoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoriesInBounds,
		arg.West,
		arg.South,
		arg.East,
		arg.North,
		arg.CurrentUserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoriesInBoundsRow
	for rows.Next() {
		var i GetStoriesInBoundsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
			&i.IsPremium,
			&i.Username,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoriesWithinRadius = `-- name: GetStoriesWithinRadius :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous, s.is_premium, u.username, u.avatar_url, u.is_premium
FROM stories s
JOIN users u ON s.user_id = u.id
WHERE 
    ST_DWithin(
    s.geom::geography,
    ST_MakePoint($1::float8, $2::float8)::geography,
    $3
  )
  AND s.expires_at > now()
  -- Allow anonymous stories (handled in presentation)
  -- AND (s.is_anonymous = false OR s.user_id = @user_id)
  AND u.is_shadow_banned = false
  AND u.is_ghost_mode = false
  -- Strict Streak Rule (DISABLED)
  -- AND DATE(u.last_active_at) >= CURRENT_DATE - INTERVAL '1 day'
  -- Block Logic: Exclude if blocked by either party (using blocked_users table)
  AND NOT EXISTS (
    SELECT 1 FROM blocked_users bu 
    WHERE (bu.blocker_id = $4 AND bu.blocked_id = s.user_id)
       OR (bu.blocker_id = s.user_id AND bu.blocked_id = $4)
  )
  -- Privacy Settings Logic --
  AND (
    -- Case 1: My own stories (always visible)
    s.user_id = $4
    OR
    (
      -- Case 2: User is NOT in Ghost Mode (using privacy_settings)
      EXISTS (
        SELECT 1 FROM privacy_settings ps 
        WHERE ps.user_id = s.user_id 
        AND ps.show_location = true -- If false (Ghost Mode), don't show in radius feed
        AND (
          -- Visibility Rules
          ps.who_can_see_stories = 'everyone'
          OR
          (ps.who_can_see_stories = 'connections' AND EXISTS (
             SELECT 1 FROM connections c 
             WHERE (c.requester_id = $4 AND c.target_id = s.user_id OR c.requester_id = s.user_id AND c.target_id = $4)
             AND c.status = 'accepted'
          ))
        )
       )
       OR
       -- Fallback: If no privacy settings exist, default to PUBLIC
       NOT EXISTS (SELECT 1 FROM privacy_settings ps WHERE ps.user_id = s.user_id)
      -- Fallback: If no privacy settings exist, assume strictly public/default behaviour? 
      -- Ideally, every user has settings. If not, default to 'everyone' + 'show_location'.
      -- But simpler to rely on LEFT JOIN or EXISTS logic assuming rows exist.
    )
  )
ORDER BY 
  (u.boost_expires_at > now()) DESC NULLS LAST,
  u.is_premium DESC,
  s.created_at DESC
`

type GetStoriesWithinRadiusParams struct {
	Lng          float64     `json:"lng"`
	Lat          float64     `json:"lat"`
	RadiusMeters interface{} `json:"radius_meters"`
	UserID       uuid.UUID   `json:"user_id"`
}

type GetStoriesWithinRadiusRow struct {
	ID           uuid.UUID         `json:"id"`
	UserID       uuid.UUID         `json:"user_id"`
	MediaUrl     string            `json:"media_url"`
	MediaType    string            `json:"media_type"`
	ThumbnailUrl sql.NullString    `json:"thumbnail_url"`
	Caption      sql.NullString    `json:"caption"`
	Geohash      string            `json:"geohash"`
	Geom         interface{}       `json:"geom"`
	Visibility   StoryAvailability `json:"visibility"`
	ExpiresAt    time.Time         `json:"expires_at"`
	CreatedAt    time.Time         `json:"created_at"`
	IsAnonymous  bool              `json:"is_anonymous"`
	IsPremium    sql.NullBool      `json:"is_premium"`
	Username     string            `json:"username"`
	AvatarUrl    sql.NullString    `json:"avatar_url"`
	IsPremium_2  sql.NullBool      `json:"is_premium_2"`
}

func (q *Queries) GetStoriesWithinRadius(ctx context.Context, arg GetStoriesWithinRadiusParams) ([]GetStoriesWithinRadiusRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoriesWithinRadius,
		arg.Lng,
		arg.Lat,
		arg.RadiusMeters,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoriesWithinRadiusRow
	for rows.Next() {
		var i GetStoriesWithinRadiusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
			&i.IsPremium,
			&i.Username,
			&i.AvatarUrl,
			&i.IsPremium_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT id, user_id, media_url, media_type, thumbnail_url, caption, geohash, geom, visibility, expires_at, created_at, is_anonymous, is_premium FROM stories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStoryByID(ctx context.Context, id uuid.UUID) (Story, error) {
	row := q.db.QueryRowContext(ctx, getStoryByID, id)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaUrl,
		&i.MediaType,
		&i.ThumbnailUrl,
		&i.Caption,
		&i.Geohash,
		&i.Geom,
		&i.Visibility,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.IsAnonymous,
		&i.IsPremium,
	)
	return i, err
}

const getStoryStats = `-- name: GetStoryStats :one
SELECT 
  COUNT(*) as total_stories,
  COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as stories_24h,
  COUNT(*) FILTER (WHERE expires_at < NOW()) as expired_stories
FROM stories
`

type GetStoryStatsRow struct {
	TotalStories   int64 `json:"total_stories"`
	Stories24h     int64 `json:"stories_24h"`
	ExpiredStories int64 `json:"expired_stories"`
}

// Admin: Story stats
func (q *Queries) GetStoryStats(ctx context.Context) (GetStoryStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryStats)
	var i GetStoryStatsRow
	err := row.Scan(&i.TotalStories, &i.Stories24h, &i.ExpiredStories)
	return i, err
}

const hasValidStory = `-- name: HasValidStory :one
SELECT EXISTS (
    SELECT 1 FROM stories 
    WHERE user_id = $1 
    AND expires_at > now()
)
`

func (q *Queries) HasValidStory(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasValidStory, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAllStories = `-- name: ListAllStories :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous, s.is_premium, u.username
FROM stories s
JOIN users u ON s.user_id = u.id
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllStoriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllStoriesRow struct {
	ID           uuid.UUID         `json:"id"`
	UserID       uuid.UUID         `json:"user_id"`
	MediaUrl     string            `json:"media_url"`
	MediaType    string            `json:"media_type"`
	ThumbnailUrl sql.NullString    `json:"thumbnail_url"`
	Caption      sql.NullString    `json:"caption"`
	Geohash      string            `json:"geohash"`
	Geom         interface{}       `json:"geom"`
	Visibility   StoryAvailability `json:"visibility"`
	ExpiresAt    time.Time         `json:"expires_at"`
	CreatedAt    time.Time         `json:"created_at"`
	IsAnonymous  bool              `json:"is_anonymous"`
	IsPremium    sql.NullBool      `json:"is_premium"`
	Username     string            `json:"username"`
}

// Admin: List all stories
func (q *Queries) ListAllStories(ctx context.Context, arg ListAllStoriesParams) ([]ListAllStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllStories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllStoriesRow
	for rows.Next() {
		var i ListAllStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
			&i.IsPremium,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
