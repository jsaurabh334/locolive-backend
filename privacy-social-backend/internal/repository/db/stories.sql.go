// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stories.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createStory = `-- name: CreateStory :one
INSERT INTO stories (
  user_id,
  media_url,
  media_type,
  geohash,
  geom,
  is_anonymous,
  expires_at
) VALUES (
  $1, $2, $3, $4, ST_SetSRID(ST_MakePoint($5::float8, $6::float8), 4326), $7, $8
) RETURNING id, user_id, media_url, media_type, thumbnail_url, caption, geohash, geom, visibility, expires_at, created_at, is_anonymous
`

type CreateStoryParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MediaUrl    string    `json:"media_url"`
	MediaType   string    `json:"media_type"`
	Geohash     string    `json:"geohash"`
	Lng         float64   `json:"lng"`
	Lat         float64   `json:"lat"`
	IsAnonymous bool      `json:"is_anonymous"`
	ExpiresAt   time.Time `json:"expires_at"`
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (Story, error) {
	row := q.db.QueryRowContext(ctx, createStory,
		arg.UserID,
		arg.MediaUrl,
		arg.MediaType,
		arg.Geohash,
		arg.Lng,
		arg.Lat,
		arg.IsAnonymous,
		arg.ExpiresAt,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaUrl,
		&i.MediaType,
		&i.ThumbnailUrl,
		&i.Caption,
		&i.Geohash,
		&i.Geom,
		&i.Visibility,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.IsAnonymous,
	)
	return i, err
}

const deleteExpiredStories = `-- name: DeleteExpiredStories :exec
DELETE FROM stories
WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredStories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredStories)
	return err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories
WHERE id = $1
`

// Admin: Delete story
func (q *Queries) DeleteStory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteStory, id)
	return err
}

const getStoriesInBounds = `-- name: GetStoriesInBounds :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous, u.username, u.avatar_url
FROM stories s
JOIN users u ON s.user_id = u.id
WHERE s.geom && ST_MakeEnvelope($1::float8, $2::float8, $3::float8, $4::float8, 4326)
AND s.expires_at > now()
AND u.is_ghost_mode = false
AND u.is_shadow_banned = false
ORDER BY s.created_at DESC
LIMIT 100
`

type GetStoriesInBoundsParams struct {
	West  float64 `json:"west"`
	South float64 `json:"south"`
	East  float64 `json:"east"`
	North float64 `json:"north"`
}

type GetStoriesInBoundsRow struct {
	ID           uuid.UUID         `json:"id"`
	UserID       uuid.UUID         `json:"user_id"`
	MediaUrl     string            `json:"media_url"`
	MediaType    string            `json:"media_type"`
	ThumbnailUrl sql.NullString    `json:"thumbnail_url"`
	Caption      sql.NullString    `json:"caption"`
	Geohash      string            `json:"geohash"`
	Geom         interface{}       `json:"geom"`
	Visibility   StoryAvailability `json:"visibility"`
	ExpiresAt    time.Time         `json:"expires_at"`
	CreatedAt    time.Time         `json:"created_at"`
	IsAnonymous  bool              `json:"is_anonymous"`
	Username     string            `json:"username"`
	AvatarUrl    sql.NullString    `json:"avatar_url"`
}

// Get stories within a bounding box for map view
func (q *Queries) GetStoriesInBounds(ctx context.Context, arg GetStoriesInBoundsParams) ([]GetStoriesInBoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoriesInBounds,
		arg.West,
		arg.South,
		arg.East,
		arg.North,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoriesInBoundsRow
	for rows.Next() {
		var i GetStoriesInBoundsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
			&i.Username,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoriesWithinRadius = `-- name: GetStoriesWithinRadius :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous FROM stories s
JOIN users u ON s.user_id = u.id
WHERE ST_DWithin(
  s.geom,
  ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)::geography,
  $3::float8
)
AND s.expires_at > now()
AND u.is_ghost_mode = false
AND u.is_shadow_banned = false
ORDER BY s.created_at DESC
`

type GetStoriesWithinRadiusParams struct {
	Lng          float64 `json:"lng"`
	Lat          float64 `json:"lat"`
	RadiusMeters float64 `json:"radius_meters"`
}

func (q *Queries) GetStoriesWithinRadius(ctx context.Context, arg GetStoriesWithinRadiusParams) ([]Story, error) {
	rows, err := q.db.QueryContext(ctx, getStoriesWithinRadius, arg.Lng, arg.Lat, arg.RadiusMeters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Story
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT id, user_id, media_url, media_type, thumbnail_url, caption, geohash, geom, visibility, expires_at, created_at, is_anonymous FROM stories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStoryByID(ctx context.Context, id uuid.UUID) (Story, error) {
	row := q.db.QueryRowContext(ctx, getStoryByID, id)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaUrl,
		&i.MediaType,
		&i.ThumbnailUrl,
		&i.Caption,
		&i.Geohash,
		&i.Geom,
		&i.Visibility,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.IsAnonymous,
	)
	return i, err
}

const getStoryStats = `-- name: GetStoryStats :one
SELECT 
  COUNT(*) as total_stories,
  COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as stories_24h,
  COUNT(*) FILTER (WHERE expires_at < NOW()) as expired_stories
FROM stories
`

type GetStoryStatsRow struct {
	TotalStories   int64 `json:"total_stories"`
	Stories24h     int64 `json:"stories_24h"`
	ExpiredStories int64 `json:"expired_stories"`
}

// Admin: Story stats
func (q *Queries) GetStoryStats(ctx context.Context) (GetStoryStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryStats)
	var i GetStoryStatsRow
	err := row.Scan(&i.TotalStories, &i.Stories24h, &i.ExpiredStories)
	return i, err
}

const listAllStories = `-- name: ListAllStories :many
SELECT s.id, s.user_id, s.media_url, s.media_type, s.thumbnail_url, s.caption, s.geohash, s.geom, s.visibility, s.expires_at, s.created_at, s.is_anonymous, u.username
FROM stories s
JOIN users u ON s.user_id = u.id
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllStoriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllStoriesRow struct {
	ID           uuid.UUID         `json:"id"`
	UserID       uuid.UUID         `json:"user_id"`
	MediaUrl     string            `json:"media_url"`
	MediaType    string            `json:"media_type"`
	ThumbnailUrl sql.NullString    `json:"thumbnail_url"`
	Caption      sql.NullString    `json:"caption"`
	Geohash      string            `json:"geohash"`
	Geom         interface{}       `json:"geom"`
	Visibility   StoryAvailability `json:"visibility"`
	ExpiresAt    time.Time         `json:"expires_at"`
	CreatedAt    time.Time         `json:"created_at"`
	IsAnonymous  bool              `json:"is_anonymous"`
	Username     string            `json:"username"`
}

// Admin: List all stories
func (q *Queries) ListAllStories(ctx context.Context, arg ListAllStoriesParams) ([]ListAllStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllStories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllStoriesRow
	for rows.Next() {
		var i ListAllStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.Caption,
			&i.Geohash,
			&i.Geom,
			&i.Visibility,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.IsAnonymous,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
